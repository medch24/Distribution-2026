let currentClass = null; let savedData = {};
let currentUserId = (window.crypto && crypto.randomUUID ? crypto.randomUUID() : (Date.now()+"-"+Math.random())).toString();
let sse; let presenceKey = null; let presenceTimer = null;
const standardHeaders = ["Mois", "Semaine", "Date", "Jour", "Unité/Chapitre", "Contenu de la leçon", "Ressources pour les leçons", "Devoir", "Ressources pour les devoirs", "Recherche", "Projets"];
const monthAbbreviations = { 'Janvier': 'Janv.', 'Février': 'Févr.', 'Mars': 'Mars', 'Avril': 'Avr.', 'Mai': 'Mai', 'Juin': 'Juin', 'Juillet': 'Juil.', 'Août': 'Août', 'Septembre': 'Sept.', 'Octobre': 'Oct.', 'Novembre': 'Nov.', 'Décembre': 'Déc.' }; 
const classSubjects = { 'TPS': ['Français', 'Maths', 'Sciences', 'ART', 'Éducation physique', 'Montessori', 'Musique', 'Bibliothèque'],'PS': ['Français', 'Maths', 'Sciences', 'ART', 'Éducation physique', 'Montessori', 'Musique', 'Bibliothèque'],'MS': ['Français', 'Maths', 'Sciences', 'Informatique', 'ART', 'Éducation physique', 'Montessori', 'Musique', 'Bibliothèque'],'GS': ['Français', 'Maths', 'Sciences', 'Informatique', 'ART', 'Éducation physique', 'Montessori', 'Musique', 'Bibliothèque'],'PP1': ['Français', 'Maths', 'Anglais', 'French second language', 'Informatique', 'Sciences Naturelles', 'Sciences Humaines', 'ART', 'Éducation physique', 'Montessori', 'Musique', 'Bibliothèque'], 'PP2': ['Français', 'Maths', 'Anglais', 'French second language', 'Informatique', 'Sciences Naturelles', 'Sciences Humaines', 'ART', 'Éducation physique', 'Montessori', 'Musique', 'Bibliothèque'],'PP3': ['Français', 'Maths', 'Anglais', 'French second language', 'Informatique', 'Sciences Naturelles', 'Sciences Humaines', 'ART', 'Éducation physique', 'Montessori', 'Musique', 'Bibliothèque'], 'PP4': ['Français', 'Maths', 'Anglais', 'French second language', 'Informatique', 'Sciences humaines', 'Sciences naturelles', 'ART', 'Éducation physique', 'Musique', 'Bibliothèque'], 'PP5': ['Français', 'Maths', 'Anglais', 'French second language', 'Informatique', 'Sciences Naturelles', 'Sciences Humaines', 'ART', 'Éducation physique', 'Musique', 'Bibliothèque'], 'PEI1': ['Langue et littérature', 'Maths', 'Sciences', 'Anglais', 'French second language', 'Design', 'Individus et Sociétés', 'ART', 'Éducation physique', 'Musique', 'Bibliothèque'], 'PEI2': ['Maths', 'Langue et littérature', 'Anglais', 'French second language', 'Biologie', 'Design', 'Individus et Sociétés', 'Physique-chimie', 'ART', 'Éducation physique', 'Musique', 'Bibliothèque'], 'PEI3': ['Maths', 'Langue et littérature', 'Anglais', 'French second language', 'Biologie', 'Design', 'Individus et Sociétés', 'Physique-chimie', 'ART', 'Éducation physique', 'Musique', 'Bibliothèque'], 'PEI4': ['Langue et littérature', 'Maths', 'Biologie', 'Physique-chimie', 'Anglais', 'French second language', 'Design', 'Individus et Sociétés', 'ART', 'Éducation physique', 'Musique', 'Bibliothèque'], 'PEI5': ['Langue et littérature', 'Maths', 'Biologie', 'Physique-chimie', 'Anglais', 'French second language', 'Design', 'Individus et Sociétés', 'ART', 'Éducation physique', 'Musique', 'Bibliothèque'], 'DP1': ['Langue et littérature', 'Maths', 'Biologie', 'Physique-chimie', 'Anglais', 'French second language', 'Design', 'Individus et Sociétés', 'ART', 'Éducation physique', 'Musique', 'Bibliothèque'], 'DP2': ['Langue et littérature', 'Maths', 'Biologie', 'Physique-chimie', 'Anglais', 'French second language', 'Design', 'Individus et Sociétés', 'ART', 'Éducation physique', 'Musique', 'Bibliothèque'] };
const classSessionCounts = {"MS": {"Français": 8, "Maths": 5, "Sciences": 4, "Éducation physique": 2, "Montessori": 2, "Musique": 1, "ART": 1, "Bibliothèque": 1}, "GS": {"Français": 10, "Maths": 5, "Sciences": 5, "Éducation physique": 2, "Informatique": 2, "Montessori": 2, "Musique": 1, "ART": 1, "Bibliothèque": 1}, "PP1": {"Français": 8, "Maths": 5, "Anglais": 3, "Sciences Humaines": 3, "Sciences Naturelles": 3, "Éducation physique": 2, "Montessori": 1, "ART": 1, "Informatique": 1, "Musique": 1, "Bibliothèque": 1}, "PP2": {"Français": 8, "Maths": 5, "Anglais": 3, "Sciences Humaines": 3, "Sciences Naturelles": 3, "Éducation physique": 2, "Montessori": 1, "ART": 1, "Informatique": 1, "Musique": 1, "Bibliothèque": 1}, "PP3": {"Français": 8, "Maths": 5, "Anglais": 3, "Sciences Humaines": 3, "Sciences Naturelles": 3, "Éducation physique": 2, "Montessori": 1, "ART": 1, "Informatique": 1, "Musique": 1, "Bibliothèque": 1}, "PP4": {"Français": 9, "Maths": 5, "Anglais": 3, "Sciences Naturelles": 3, "Sciences Humaines": 3, "Éducation physique": 2, "Informatique": 1, "Musique": 1, "ART": 1, "Bibliothèque": 1}, "PP5": {"Français": 9, "Maths": 5, "Anglais": 3, "Sciences Naturelles": 3, "Sciences Humaines": 3, "Éducation physique": 2, "Informatique": 1, "Musique": 1, "ART": 1, "Bibliothèque": 1}, "PEI1": {"Langue et littérature": 6, "Maths": 5, "Sciences": 5, "Individus et Sociétés": 3, "Anglais": 3, "Design": 2, "Éducation physique": 2, "Musique": 1, "ART": 1, "Bibliothèque": 1}, "PEI2": {"Langue et littérature": 5, "Maths": 5, "Individus et Sociétés": 3, "Biologie": 3, "Design": 3, "Physique-chimie": 3, "Anglais": 3, "Éducation physique": 1, "Musique": 1, "ART": 1, "Bibliothèque": 1}, "PEI3": {"Langue et littérature": 5, "Maths": 5, "Individus et Sociétés": 3, "Biologie": 3, "Design": 3, "Physique-chimie": 3, "Anglais": 3, "Éducation physique": 1, "Musique": 1, "ART": 1, "Bibliothèque": 1}, "PEI4": {"Langue et littérature": 5, "Maths": 5, "Biologie": 4, "Physique-chimie": 4, "Anglais": 3, "French second language": 2, "Design": 2, "Individus et Sociétés": 2, "Éducation physique": 1, "Musique": 1, "ART": 1, "Bibliothèque": 1}, "PEI5": {"Langue et littérature": 5, "Maths": 5, "Biologie": 4, "Physique-chimie": 4, "Anglais": 3, "French second language": 2, "Design": 2, "Individus et Sociétés": 2, "Éducation physique": 1, "Musique": 1, "ART": 1, "Bibliothèque": 1}, "DP1": {"Langue et littérature": 4, "Maths": 5, "Biologie": 4, "Physique-chimie": 4, "Anglais": 3, "French second language": 2, "Design": 2, "Individus et Sociétés": 2, "Éducation physique": 1, "Musique": 1, "ART": 1, "Bibliothèque": 1}, "DP2": {"Langue et littérature": 4, "Maths": 5, "Biologie": 4, "Physique-chimie": 4, "Anglais": 3, "French second language": 2, "Design": 2, "Individus et Sociétés": 2, "Éducation physique": 1, "Musique": 1, "ART": 1, "Bibliothèque": 1} };
// Load calendar from server if missing (prevents empty tables on cold start)
let academicCalendar = [];

// Build a sane default academic calendar if none is provided by the project
(function ensureCalendar() {
  if (Array.isArray(academicCalendar) && academicCalendar.length > 0) return;
  const months = ['Septembre','Octobre','Novembre','Décembre','Janvier','Février','Mars','Avril','Mai','Juin'];
  const days = ['Dimanche','Lundi','Mardi','Mercredi','Jeudi']; // 5 jours d'école
  let week = 1;
  let monthIndex = 0;
  // 31 semaines d'enseignement, 5 jours chacune
  for (let w = 0; w < 31; w++) {
    const month = months[monthIndex];
    for (let d = 0; d < days.length; d++) {
      academicCalendar.push({
        month,
        week: `Semaine ${week}`,
        date: '',
        day: days[d],
        type: 'Cours'
      });
    }
    week++;
    // Change month approximately every 4 weeks
    if ((w + 1) % 4 === 0 && monthIndex < months.length - 1) monthIndex++;
  }
})();


const isPlannable = (event) => event && event.type === 'Cours';
const isSpecialDay = (event) => { if (!event) return false; const type = event.type.toLowerCase(); return type.includes('day') || type.includes('examen') || type.includes('fête') || type.includes('férié') || type.includes('congé') || type.includes('weekend') || type.includes('evaluation'); };

function showErrorMessage(message, duration = 5000) { let errorDiv = document.getElementById('errorMessage'); if (!errorDiv) { errorDiv = document.createElement('div'); errorDiv.id = 'errorMessage'; errorDiv.style.cssText = `position: fixed; top: 20px; right: 20px; background-color: #fde8e8; color: #7f1d1d; padding: 15px; border: 1px solid #fecaca; border-radius: 5px; max-width: 400px; z-index: 1000; box-shadow: 0 4px 6px rgba(0,0,0,0.1); font-size: 14px;`; document.body.appendChild(errorDiv); } errorDiv.textContent = message; errorDiv.style.display = 'block'; setTimeout(() => { if (errorDiv) errorDiv.style.display = 'none'; }, duration); }
function showSuccessMessage(message, duration = 3000) { let successDiv = document.getElementById('successMessage'); if (!successDiv) { successDiv = document.createElement('div'); successDiv.id = 'successMessage'; successDiv.style.cssText = `position: fixed; top: 20px; right: 20px; background-color: #ecfdf5; color: #064e3b; padding: 15px; border: 1px solid #bbf7d0; border-radius: 5px; max-width: 400px; z-index: 1000; box-shadow: 0 4px 6px rgba(0,0,0,0.1); font-size: 14px;`; document.body.appendChild(successDiv); } successDiv.textContent = message; successDiv.style.display = 'block'; setTimeout(() => { if (successDiv) successDiv.style.display = 'none'; }, duration); }

async function apiCall(endpoint, payload) { try { const response = await fetch(`/api/${endpoint}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload), }); if (!response.ok) { let errorMessage = `Erreur du serveur: ${response.status}`; try { const errorData = await response.json(); errorMessage = errorData.error || errorMessage; } catch (parseError) { errorMessage = response.statusText || errorMessage; } throw new Error(errorMessage); } if (endpoint === 'generatePdfOnServer') { return response.blob(); } return response.json(); } catch (error) { console.error(`Erreur API pour ${endpoint}:`, error); showErrorMessage(`Erreur: ${error.message}`); throw error; } }

function initSSE() { if (sse) return; try { sse = new EventSource('/api/events'); sse.addEventListener('refresh', (ev) => { try { const data = JSON.parse(ev.data || '{}'); if (!currentClass) return; location.reload(); } catch(_) {} }); sse.addEventListener('presence', (ev) => { try { const data = JSON.parse(ev.data || '{}'); if (data && presenceKey && data.key === presenceKey) { const bar = document.getElementById('presenceBar'); if (bar) { const others = Math.max(0, (data.count || 0)); bar.textContent = others > 1 ? `${others} utilisateurs dans cette matière` : (others === 1 ? `1 utilisateur dans cette matière` : ''); bar.style.display = others > 0 ? 'block' : 'none'; } } } catch(_) {} }); } catch (_) {} }

async function goToClass(className) { currentClass = className; document.getElementById('initialSelection').style.display = 'none'; document.getElementById('classView').style.display = 'block'; initSSE(); document.getElementById('classTitle').textContent = `Classe ${className}`; savedData = {}; document.getElementById('matiereSelect').innerHTML = "<option value=''>Sélectionner une matière</option>"; document.getElementById('output').innerHTML = ""; document.getElementById('filterBy').value = ""; document.getElementById('filterOptions').style.display = 'none'; document.getElementById('showFilledOnly').checked = false; if (!className) return; showProgressBar(); try { const [tableResponse, allSelectionsResponse] = await Promise.all([ apiCall('loadLatestCopy', { className }), apiCall('loadAllSelectionsForClass', { className }) ]); if (tableResponse.success && Array.isArray(tableResponse.tables)) { tableResponse.tables.forEach(({ matiere, data }) => { savedData[matiere] = data; }); } populateMatiereSelect(className); const subjects = classSubjects[className] || []; subjects.forEach(subject => { if (!savedData[subject] || savedData[subject].length <= 1) { savedData[subject] = generateInitialData(); } }); if (subjects.length > 0) { document.getElementById('matiereSelect').value = subjects[0]; displaySelectedTable(); } } catch (error) { console.error("Erreur lors du chargement de la classe:", error); showErrorMessage("Erreur de chargement de la classe: " + error.message); } finally { hideProgressBar(); } }

async function resetCurrentMatiere() { const selectedMatiere = document.getElementById('matiereSelect').value; if (!currentClass || !selectedMatiere) { alert("Veuillez sélectionner une classe et une matière."); return; } if (!confirm(`Êtes-vous sûr de vouloir réinitialiser "${selectedMatiere}" avec le calendrier 2025-2026?\n\nToutes les données existantes seront remplacées par le nouveau calendrier.`)) { return; } showProgressBar(); try { savedData[selectedMatiere] = generateInitialData(); const ack = await apiCall('saveTable', { className: currentClass, sheetName: selectedMatiere, data: savedData[selectedMatiere] }); if (ack.success) { showSuccessMessage(`"${selectedMatiere}" a été réinitialisée avec le calendrier 2025-2026 (31 semaines)!`); displaySelectedTable(); } } catch (error) { showErrorMessage("Erreur lors de la réinitialisation: " + error.message); } finally { hideProgressBar(); } }

async function heartbeatPresence() { try { if (!presenceKey) return; await apiCall('presence/heartbeat', { className: presenceKey.split(':')[0], sheetName: presenceKey.split(':')[1], userId: currentUserId }); } catch (_) {} }

async function saveTable(isSilent = false) { const selectedMatiere = document.getElementById('matiereSelect').value; if (!currentClass || !selectedMatiere || !savedData[selectedMatiere]) { if (!isSilent) alert("Veuillez sélectionner une classe et une matière."); return; } if (savedData[selectedMatiere].length <= 1) { if (!isSilent) alert("Aucune donnée à enregistrer."); return; } if (!isSilent) showProgressBar(); try { const ack = await apiCall('saveTable', { className: currentClass, sheetName: selectedMatiere, data: savedData[selectedMatiere] }); if (ack.success) { if (!isSilent) showSuccessMessage("Modifications enregistrées avec succès!"); } } catch (error) { if (!isSilent) showErrorMessage("Erreur lors de l'enregistrement: " + error.message); } finally { if (!isSilent) hideProgressBar(); } }

async function deleteMatiereData() { const selectedMatiere = document.getElementById('matiereSelect').value; if (!currentClass || !selectedMatiere) { alert("Veuillez sélectionner une classe et une matière à supprimer."); return; } if (confirm(`Êtes-vous sûr de vouloir supprimer TOUTES les données pour la matière "${selectedMatiere}" dans la classe ${currentClass} ?\nCette action est irréversible.`)) { showProgressBar(); try { const ack = await apiCall('deleteMatiereData', { className: currentClass, sheetName: selectedMatiere }); if (ack.success) { alert(`Les données pour la matière "${selectedMatiere}" ont été supprimées.`); savedData[selectedMatiere] = generateInitialData(); displaySelectedTable(); } } catch (error) { alert("Erreur lors de la suppression des données : " + error.message); } finally { hideProgressBar(); } } }

async function generatePdf() { const selectedMatiere = document.getElementById('matiereSelect').value; if (!currentClass || !selectedMatiere) { alert("Veuillez sélectionner une classe et une matière."); return; } showProgressBar(); try { const response = await fetch('https://docs.google.com/document/d/1FLux_zEr90hvMRRODtex0c7d5tHTtFS1/export?format=docx'); if (!response.ok) throw new Error("Le modèle Word n'a pas pu être chargé."); const template = await response.arrayBuffer(); const zip = new PizZip(template); const doc = new docxtemplater(zip, { paragraphLoop: true, linebreaks: true, nullGetter: () => "" }); const templateData = prepareWordDataForSubject(selectedMatiere, savedData[selectedMatiere], currentClass); doc.render(templateData); const docxBuffer = doc.getZip().generate({ type: 'uint8array' }); const base64String = btoa(String.fromCharCode.apply(null, docxBuffer)); const pdfBlob = await apiCall('generatePdfOnServer', { docxBuffer: base64String, fileName: `${currentClass}_${selectedMatiere}_Distribution.docx` }); saveAs(pdfBlob, `${currentClass}_${selectedMatiere}_Distribution.pdf`); } catch (error) { console.error('Erreur lors de la génération du PDF:', error); alert('Une erreur est survenue lors de la génération du PDF: ' + error.message); } finally { hideProgressBar(); } }

async function generateWord() { const selectedMatiere = document.getElementById('matiereSelect').value; if (!currentClass || !selectedMatiere) { alert("Veuillez sélectionner une classe et une matière."); return; } showProgressBar(); try { const response = await fetch('https://docs.google.com/document/d/1uFWwBSy4RuF6d5zpy_2nOa43Q4ITm3Bs/export?format=docx'); if (!response.ok) throw new Error("Le modèle Word n'a pas pu être chargé."); const template = await response.arrayBuffer(); const zip = new PizZip(template); const doc = new docxtemplater(zip, { paragraphLoop: true, linebreaks: true, nullGetter: () => "" }); const templateData = prepareWordDataForSubject(selectedMatiere, savedData[selectedMatiere], currentClass); doc.render(templateData); const docxBlob = doc.getZip().generate({ type: 'blob', mimeType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' }); saveAs(docxBlob, `${currentClass}_${selectedMatiere}_Distribution.docx`); showSuccessMessage("Document Word généré avec succès!"); } catch (error) { console.error('Erreur lors de la génération du document Word:', error); showErrorMessage('Une erreur est survenue lors de la génération du document Word: ' + error.message); } finally { hideProgressBar(); } }

async function generateWordZipForClass() { if (!currentClass) { alert("Veuillez d'abord sélectionner une classe."); return; } if (Object.keys(savedData).length === 0) { alert("Les données de la classe ne sont pas encore chargées. Veuillez patienter ou recharger."); return; } showProgressBar(); try { const response = await fetch('https://docs.google.com/document/d/1uFWwBSy4RuF6d5zpy_2nOa43Q4ITm3Bs/export?format=docx'); if (!response.ok) throw new Error("Le modèle Word n'a pas pu être chargé."); const template = await response.arrayBuffer(); const zip = new JSZip(); const subjects = classSubjects[currentClass]; if (!subjects || subjects.length === 0) { throw new Error("Aucune matière n'est définie pour cette classe."); } for (const subject of subjects) { if (savedData[subject] && savedData[subject].length > 1) { try { const templateZip = new PizZip(template); const doc = new docxtemplater(templateZip, { paragraphLoop: true, linebreaks: true, nullGetter: () => "" }); const templateData = prepareWordDataForSubject(subject, savedData[subject], currentClass); doc.render(templateData); const docxBuffer = doc.getZip().generate({ type: 'uint8array' }); zip.file(`${currentClass}_${subject}_Distribution.docx`, docxBuffer); } catch (docError) { console.warn(`Erreur lors de la génération du document pour ${subject}:`, docError); } } } if (Object.keys(zip.files).length > 0) { const content = await zip.generateAsync({ type: "blob" }); saveAs(content, `Distribution_Word_${currentClass}.zip`); showSuccessMessage("Archive ZIP des documents Word générée avec succès!"); } else { alert("Aucun document Word n'a pu être généré. Vérifiez que les matières contiennent des données."); } } catch (error) { console.error('Erreur lors de la génération du ZIP de fichiers Word:', error); showErrorMessage('Une erreur est survenue : ' + error.message); } finally { hideProgressBar(); } }

function generateInitialData(calendar = academicCalendar) { const data = [standardHeaders]; calendar.forEach(event => { const weekLabel = event.week; const newRow = Array(standardHeaders.length).fill(''); newRow[0] = event.month; newRow[1] = weekLabel; newRow[2] = event.date; newRow[3] = event.day; newRow[4] = event.type || 'Cours Normal'; data.push(newRow); }); return data; }

function showClasses(section) { document.querySelectorAll('.section-classes').forEach(div => { div.style.display = 'none'; }); document.getElementById(section).style.display = 'block'; }
function showInitialSelection() { document.getElementById('classView').style.display = 'none'; document.getElementById('initialSelection').style.display = 'block'; currentClass = null; savedData = {}; document.getElementById('matiereSelect').innerHTML = "<option value=''>Sélectionner une matière</option>"; document.getElementById('output').innerHTML = ""; document.getElementById('filterBy').value = ""; document.getElementById('filterOptions').innerHTML = ""; document.getElementById('filterOptions').style.display = 'none'; document.getElementById('showFilledOnly').checked = false; }

function populateMatiereSelect(className) { const select = document.getElementById('matiereSelect'); select.innerHTML = "<option value=''>Sélectionner une matière</option>"; const subjects = classSubjects[className]; if (subjects) { subjects.forEach(subject => { const option = document.createElement('option'); option.value = subject; option.textContent = subject; select.appendChild(option); }); } }

function displaySelectedTable() { const selectedMatiere = document.getElementById('matiereSelect').value; presenceKey = currentClass && selectedMatiere ? `${currentClass}:${selectedMatiere}` : null; if (presenceTimer) { clearInterval(presenceTimer); presenceTimer = null; } if (presenceKey) { initSSE(); heartbeatPresence(); presenceTimer = setInterval(heartbeatPresence, 10000); }
  if (selectedMatiere && currentClass) { if (!savedData[selectedMatiere] || savedData[selectedMatiere].length <= 1) { savedData[selectedMatiere] = generateInitialData(); } renderTable(selectedMatiere, savedData[selectedMatiere]); } else { document.getElementById('output').innerHTML = ""; } }

function renderTable(sheetName, jsonData) { const output = document.getElementById('output'); output.innerHTML = ""; const table = document.createElement('table'); const thead = document.createElement('thead'); const headerRow = document.createElement('tr'); const displayedHeaders = ["Mois", "Sem.", "Séan.", "Unité/Chapitre", "Contenu de la leçon", "Ressources (Leçons)", "Devoir", "Ressources (Devoirs)", "Recherche", "Projets"]; displayedHeaders.forEach(col => { const th = document.createElement('th'); th.textContent = col; headerRow.appendChild(th); }); thead.appendChild(headerRow); table.appendChild(thead); const tbody = document.createElement('tbody'); let sessionCounters = {}; let weekMaxSessions = {}; const baseSessionsPerWeek = (classSessionCounts[currentClass] && classSessionCounts[currentClass][sheetName]) || 5; 
  jsonData.slice(1).forEach((row, dataIndex) => { const event = academicCalendar[dataIndex]; if (!event) return; const weekValue = event.week; if(!weekMaxSessions[weekValue]) { const specialDaysCount = jsonData.slice(1).filter((r, i) => { const e = academicCalendar[i]; return e && e.week === weekValue && !isPlannable(e) && isSpecialDay(e); }).length; weekMaxSessions[weekValue] = Math.max(1, baseSessionsPerWeek - specialDaysCount); }
    if(!sessionCounters[weekValue]) sessionCounters[weekValue] = 0; const isSpecialEvent = !isPlannable(event); const sessionsPerWeek = weekMaxSessions[weekValue]; const renderSession = (sessionNum) => { const rowElement = document.createElement('tr'); const originalRowIndex = savedData[sheetName].findIndex(originalRow => originalRow === row); const rowIndexForDB = originalRowIndex !== -1 ? originalRowIndex - 1 : -1; const monthTd = document.createElement('td'); monthTd.textContent = monthAbbreviations[row[0]] || row[0] || ''; rowElement.appendChild(monthTd); const weekTd = document.createElement('td'); if (isSpecialEvent) { weekTd.textContent = ''; } else { weekTd.textContent = row[1] ? row[1].replace('Semaine ', 'S') : ''; } rowElement.appendChild(weekTd); const seanceTd = document.createElement('td'); if (!isSpecialEvent) { seanceTd.textContent = sessionNum; } rowElement.appendChild(seanceTd); if (isSpecialEvent) { const mergedCell = document.createElement('td'); mergedCell.colSpan = displayedHeaders.length - 3; mergedCell.innerHTML = `<b>${event.type}</b>`; mergedCell.classList.add('merged-cell'); let bgColor = '#f2f2f2'; const typeLC = event.type.toLowerCase(); if (typeLC.includes('vacance')) bgColor = '#90EE90'; else if (typeLC.includes('examen')) bgColor = '#FFA07A'; else if (typeLC.includes('evaluation') || typeLC.includes('évaluation')) bgColor = '#FFB6C1'; else if (typeLC.includes('day')) bgColor = '#ADD8E6'; else if (typeLC.includes('orientation')) bgColor = '#FFD700'; else if (typeLC.includes('weekend')) bgColor = '#D3D3D3'; mergedCell.style.backgroundColor = bgColor; rowElement.appendChild(mergedCell); } else { for (let i = 4; i < standardHeaders.length; i++) { const td = document.createElement('td'); const input = document.createElement('textarea'); input.value = row[i] || ''; input.className = 'modifiable-input'; input.dataset.rowIndex = rowIndexForDB; input.dataset.colIndex = i; td.appendChild(input); rowElement.appendChild(td); } } tbody.appendChild(rowElement); };
    if (isSpecialEvent) { renderSession(null); } else { const remainingSessions = sessionsPerWeek - sessionCounters[weekValue]; if (remainingSessions > 0) { const remainingDays = jsonData.slice(dataIndex).filter((r, i) => { const e = academicCalendar[dataIndex + i]; return e && e.week === weekValue && isPlannable(e); }).length; if (remainingDays > 0) { const sessionsThisDay = Math.ceil(remainingSessions / remainingDays); const actualSessions = Math.min(sessionsThisDay, remainingSessions); for (let s = 0; s < actualSessions; s++) { sessionCounters[weekValue]++; renderSession(sessionCounters[weekValue]); } } } } }); table.appendChild(tbody); output.appendChild(table); addEventListenersToTable(sheetName); applyFilter(); }

function addEventListenersToTable(sheetName) { document.querySelectorAll('#output .modifiable-input').forEach(input => { input.addEventListener('input', (e) => { const rowIndex = parseInt(e.target.dataset.rowIndex); const colIndex = parseInt(e.target.dataset.colIndex); if (rowIndex >= 0 && savedData[sheetName]?.[rowIndex + 1]) { savedData[sheetName][rowIndex + 1][colIndex] = e.target.value; } }); }); }

function populateFilterOptions() { const filterBy = document.getElementById('filterBy').value; const selectedMatiere = document.getElementById('matiereSelect').value; const filterOptionsSelect = document.getElementById('filterOptions'); filterOptionsSelect.innerHTML = ''; filterOptionsSelect.style.display = 'none'; if (!selectedMatiere || !filterBy || !savedData[selectedMatiere]) { return; } const columnIndex = {Mois: 0, Semaine: 1}[filterBy]; if (columnIndex === undefined) { return; } const options = new Set(); const data = savedData[selectedMatiere]; if (data && data.length > 1) { data.slice(1).forEach((row, i) => { const event = academicCalendar[i]; if (event) { const cellValue = (filterBy === 'Mois' ? event.month : event.week); if (cellValue) { options.add(cellValue); } } }); } if (options.size > 0) { filterOptionsSelect.style.display = 'inline-block'; filterOptionsSelect.innerHTML = '<option value="">Tous</option>'; Array.from(options).sort((a, b) => { if (filterBy === 'Semaine') { const aNum = parseInt(a.replace('Semaine ', '')); const bNum = parseInt(b.replace('Semaine ', '')); return aNum - bNum; } return a.localeCompare(b); }).forEach(optionValue => { filterOptionsSelect.innerHTML += `<option value="${optionValue}">${optionValue}</option>`; }); } applyFilter(); }

function applyFilter() { toggleFilledRows(); }

function clearFilter() { document.getElementById('filterBy').value = ""; document.getElementById('filterOptions').innerHTML = ""; document.getElementById('filterOptions').style.display = 'none'; document.getElementById('showFilledOnly').checked = false; toggleFilledRows(); }

function toggleFilledRows() { const showFilledOnly = document.getElementById('showFilledOnly').checked; const tableBody = document.querySelector('#output table tbody'); if (!tableBody) return; const filterBy = document.getElementById('filterBy').value; const filterValue = document.getElementById('filterOptions').value; tableBody.querySelectorAll('tr').forEach((rowElement) => { let isVisible = true; const monthCell = rowElement.querySelector('td:nth-child(1)'); const weekCell = rowElement.querySelector('td:nth-child(2)'); if (filterBy && filterValue && monthCell && weekCell) { const monthValue = monthCell.textContent.trim(); const weekValue = weekCell.textContent.trim(); if (filterBy === 'Mois') { const fullMonth = Object.keys(monthAbbreviations).find(key => monthAbbreviations[key] === monthValue); if (fullMonth !== filterValue && monthValue !== filterValue) { isVisible = false; } } else if (filterBy === 'Semaine') { const fullWeek = weekValue.startsWith('S') ? 'Semaine ' + weekValue.substring(1) : weekValue; if (fullWeek !== filterValue && weekValue !== filterValue) { isVisible = false; } } } if (showFilledOnly && isVisible) { let isFilled = false; if (rowElement.querySelector('.merged-cell')) { isFilled = false; } else { const textInputs = rowElement.querySelectorAll('.modifiable-input'); textInputs.forEach(input => { if (input.value.trim() !== '') isFilled = true; }); } if (!isFilled) isVisible = false; } rowElement.style.display = isVisible ? '' : 'none'; }); }

function showProgressBar(){const bar=document.getElementById('progressBar');bar.style.display='block';bar.firstElementChild.style.width='10%';}
function hideProgressBar(){const bar=document.getElementById('progressBar');bar.style.display='none';bar.firstElementChild.style.width='0';}

async function handleDocxImport(event) { const selectedMatiere = document.getElementById('matiereSelect').value; if (!currentClass || !selectedMatiere) { alert("Veuillez d'abord sélectionner une classe et une matière."); event.target.value = ''; return; } const file = event.target.files[0]; if (!file) return; showProgressBar(); try { const arrayBuf = await file.arrayBuffer(); const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuf))); const resp = await apiCall('importDocxAnalyze', { className: currentClass, sheetName: selectedMatiere, fileName: file.name, fileBase64: base64 }); if (resp.success && Array.isArray(resp.sessions)) { const sessions = resp.sessions; const sessionsPerWeek = (classSessionCounts[currentClass] && classSessionCounts[currentClass][selectedMatiere]) || 5; const slots = []; let counters = {}; savedData[selectedMatiere].slice(1).forEach((row, idx) => { const ev = academicCalendar[idx]; if (!ev) return; const week = ev.week; if (!counters[week]) counters[week] = 0; if (isPlannable(ev)) { if (counters[week] < sessionsPerWeek) { slots.push(row); } counters[week]++; } }); let i = 0; for (const slot of slots) { if (i >= sessions.length) break; const it = sessions[i++]; slot[4] = (it.unite || '').toString(); slot[5] = (it.contenu || '').toString(); slot[6] = (it.ressources_lecon || '').toString(); slot[7] = (it.devoir || '').toString(); slot[8] = (it.ressources_devoir || '').toString(); slot[9] = (it.recherche || '').toString(); slot[10] = (it.projet || '').toString(); } const weekGroups = {}; savedData[selectedMatiere].slice(1).forEach((row, idx) => { const ev = academicCalendar[idx]; if (!ev) return; if (!weekGroups[ev.week]) weekGroups[ev.week] = []; weekGroups[ev.week].push(row); }); Object.keys(weekGroups).forEach(w => { const rows = weekGroups[w]; const last = rows[rows.length - 1]; const lastTheme = rows.map(r => r[4]).filter(Boolean).pop() || selectedMatiere; if (last) { if (!last[9]) last[9] = `Recherche: approfondissement sur ${lastTheme}`; if (!last[10]) last[10] = `Projet: application pratique sur ${lastTheme}`; } }); renderTable(selectedMatiere, savedData[selectedMatiere]); await saveTable(true); showSuccessMessage('Import Word terminé et plan auto-rempli (IA).'); } else { showErrorMessage('Réponse IA invalide.'); } } catch (err) { console.error(err); showErrorMessage('Import DOCX échoué: ' + err.message); } finally { hideProgressBar(); event.target.value = ''; } }

function handleFileUpload(event) { if (!currentClass || !document.getElementById('matiereSelect').value) { alert("Veuillez d'abord sélectionner une classe et une matière."); event.target.value = ''; return; } const file = event.target.files[0]; if (file) { showProgressBar(); const reader = new FileReader(); reader.onload = async (e) => { try { const data = new Uint8Array(e.target.result); const workbook = XLSX.read(data, { type: 'array' }); const firstSheetName = workbook.SheetNames[0]; const worksheet = workbook.Sheets[firstSheetName]; const importedData = XLSX.utils.sheet_to_json(worksheet, { header: 1 }); fillTableWithExcelData(importedData); } catch (error) { console.error("Erreur lors de l'importation du fichier:", error); alert("Une erreur s'est produite lors de la lecture du fichier Excel."); } finally { hideProgressBar(); event.target.value = ''; } }; reader.readAsArrayBuffer(file); } }

function fillTableWithExcelData(importedData) { const selectedMatiere = document.getElementById('matiereSelect').value; if (!currentClass || !selectedMatiere) { alert("Veuillez d'abord sélectionner une classe et une matière."); return; } const headerOffset = importedData[0]?.[0]?.toLowerCase().includes('unité') || importedData[0]?.[1]?.toLowerCase().includes('contenu') ? 1 : 0; const dataToImport = importedData.slice(headerOffset); const sessionsPerWeek = (classSessionCounts[currentClass] && classSessionCounts[currentClass][selectedMatiere]) || 0; const availableSlots = []; let sessionCounters = {}; savedData[selectedMatiere].slice(1).forEach((appRow, appRowIndex) => { const event = academicCalendar[appRowIndex]; const weekValue = event.week; if(!sessionCounters[weekValue]) sessionCounters[weekValue] = 0; if (isPlannable(event)) { if (sessionCounters[weekValue] < sessionsPerWeek) { availableSlots.push(appRow); } sessionCounters[weekValue]++; } }); dataToImport.forEach((importedRow, importIndex) => { if (importIndex < availableSlots.length) { const targetRow = availableSlots[importIndex]; for(let i = 0; i < 7; i++) { targetRow[i + 4] = importedRow[i] || ''; } } }); renderTable(selectedMatiere, savedData[selectedMatiere]); saveTable(true); alert('Importation terminée ! Les données ont été insérées uniquement dans les séances prévues pour cette matière.'); }

function prepareExcelDataForSubject(subjectName) { const sheetData = savedData[subjectName]; if (!sheetData || sheetData.length <= 1) { return null; } const exportHeaders = ["Mois", "Semaine", "Séance", "Unité/Chapitre", "Contenu de la leçon", "Ressources pour les leçons", "Devoir", "Ressources pour les devoirs", "Recherche", "Projets"]; const dataForExport = [exportHeaders]; let sessionCounters = {}; let weekMaxSessions = {}; const baseSessionsPerWeek = (classSessionCounts[currentClass] && classSessionCounts[currentClass][subjectName]) || 5; sheetData.slice(1).forEach((row, dataIndex) => { const event = academicCalendar[dataIndex]; if (!event) return; const weekValue = event.week; if (!weekMaxSessions[weekValue]) { const specialDays = sheetData.slice(1).filter((r, i) => { const e = academicCalendar[i]; return e && e.week === weekValue && !isPlannable(e) && isSpecialDay(e); }).length; weekMaxSessions[weekValue] = Math.max(1, baseSessionsPerWeek - specialDays); } if (!sessionCounters[weekValue]) sessionCounters[weekValue] = 0; const sessionsPerWeek = weekMaxSessions[weekValue]; let seanceValue = ''; if (isPlannable(event)) { if (sessionCounters[weekValue] < sessionsPerWeek) { sessionCounters[weekValue]++; seanceValue = sessionCounters[weekValue]; } else { return; } } if (!isPlannable(event)) { dataForExport.push([ monthAbbreviations[row[0]] || row[0] || '', '', '', event.type, '', '', '', '', '', '' ]); } else { dataForExport.push([ monthAbbreviations[row[0]] || row[0] || '', row[1] ? row[1].replace('Semaine ', 'S') : '', seanceValue, row[4] || '', row[5] || '', row[6] || '', row[7] || '', row[8] || '', row[9] || '', row[10] || '' ]); } }); return dataForExport; }

function prepareWordDataForSubject(subjectName, subjectData, className) { const data = subjectData.slice(1); const dataForWord = data.filter((row, i) => academicCalendar[i] && academicCalendar[i].month !== 'Août'); const calendarForWord = academicCalendar.filter(event => event && event.month !== 'Août'); const dataByWeek = {}; function getWeekNumber(weekString) { const match = weekString.match(/Semaine (\d+)/); return match ? parseInt(match[1], 10) : null; } dataForWord.forEach((row, index) => { const event = calendarForWord[index]; if (!event) return; const week = event.week; const weekNum = getWeekNumber(week); if (weekNum && !dataByWeek[weekNum]) { dataByWeek[weekNum] = { week_name: week, seances: [] }; } }); let sessionCounters = {}; let weekMaxSessions = {}; const baseSessionsPerWeek = (classSessionCounts[className] && classSessionCounts[className][subjectName]) || 5; dataForWord.forEach((row, index) => { const event = calendarForWord[index]; if (!event) return; const week = event.week; const weekNum = getWeekNumber(week); if (!weekNum) return; if (!weekMaxSessions[weekNum]) { const specialDays = calendarForWord.filter((e) => { return e && e.week === week && !isPlannable(e) && isSpecialDay(e); }).length; weekMaxSessions[weekNum] = Math.max(1, baseSessionsPerWeek - specialDays); } if (!sessionCounters[weekNum]) sessionCounters[weekNum] = 0; const isSpecialEvent = !isPlannable(event); const sessionsPerWeek = weekMaxSessions[weekNum]; if (!isSpecialEvent) { const remainingSessions = sessionsPerWeek - sessionCounters[weekNum]; if (remainingSessions > 0) { const remainingDays = calendarForWord.slice(index).filter((e) => { return e && e.week === week && isPlannable(e); }).length; if (remainingDays > 0) { const sessionsThisDay = Math.ceil(remainingSessions / remainingDays); const actualSessions = Math.min(sessionsThisDay, remainingSessions); for (let s = 0; s < actualSessions; s++) { sessionCounters[weekNum]++; const seanceData = { seance_num: sessionCounters[weekNum], chapitre: row[4] || '', contenu_lecon: row[5] || '', res_lecon: row[6] || '', devoir: row[7] || '', res_devoir: row[8] || '', recherche: row[9] || '', projet: row[10] || '' }; dataByWeek[weekNum].seances.push(seanceData); } } } } else { const weekSeances = dataByWeek[weekNum].seances; if (!weekSeances.some(s => s.chapitre === event.type)) { const specialSeance = { seance_num: ' ', chapitre: event.type, contenu_lecon: '', res_lecon: '', devoir: '', res_devoir: '', recherche: '', projet: '' }; dataByWeek[weekNum].seances.push(specialSeance); } } }); const templateData = { class_name: className, subject_name: subjectName }; Object.keys(dataByWeek).forEach(weekNum => { const weekData = dataByWeek[weekNum]; const weekKey = `week${weekNum}`; const sortedSeances = weekData.seances.sort((a, b) => { if (a.seance_num === ' ') return -1; if (b.seance_num === ' ') return 1; return a.seance_num - b.seance_num; }); templateData[`${weekKey}_name`] = weekData.week_name; templateData[`${weekKey}_seances`] = sortedSeances; }); return templateData; }

showInitialSelection();